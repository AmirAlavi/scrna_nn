#!/usr/bin/env python
"""Impute missing data

Usage:
    impute.py <expression_h5> [--threshold=<thresh> -k=<k>]
    impute.py (-h | --help)
    impute.py --version

Options:
    -h --help                         Show this screen.
    --version                         Show version.
    -t <thresh> --threshold=<thresh>  Missing value threshold. Float between 0
                                      and 1.0. Only keep cells with at most
                                      this percentage of missing data (genes).
                                      [default: 0.25]
    -k <k>                            Num neighbors for kNN-impute.
                                      [default: 10]

"""

#import json
#import pdb; pdb.set_trace()
import time
#from collections import defaultdict, namedtuple
#from typing import List, Tuple

#import mygene
import numpy as np
import pandas as pd
from docopt import docopt
from scipy.spatial.distance import cdist, pdist, squareform
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt

def get_accessions_from_accessionSeries(accessionSeries_list):
    accessions = []
    for accessionSeries in accessionSeries_list:
        accession = accessionSeries.split('_')[0]
        accessions.append(accession)
    return np.array(accessions)


def write_data_to_h5(name, df, labels, true_cell_ids=None, gene_symbols=None):
    print(df.shape)
    if not gene_symbols:
        gene_symbols = convert_entrez_to_symbol(df.columns)
    # Add these as Datasets in the hdf5 file
    gene_symbols_series = pd.Series(data=gene_symbols, index=df.columns)
    accessions = get_accessions_from_accessionSeries(df.index)
    accessions_series = pd.Series(data=accessions, index=df.index)
    labels_series = pd.Series(data=labels, index=df.index)

    new_h5_store = pd.HDFStore(name)
    new_h5_store['accessions'] = accessions_series
    new_h5_store['gene_symbols'] = gene_symbols_series
    new_h5_store['rpkm'] = df
    new_h5_store['labels'] = labels_series

    if true_cell_ids is not None:
        new_h5_store['true_ids'] = pd.Series(data=true_cell_ids, index=df.index)
    new_h5_store.close()

    return gene_symbols


def filter_cells(df, missing_threshold):
    """Remove cells that have more than a given threshold percentage of missing values
    """
    nans = df.isnull().values
    print(nans.shape)
    num_genes = nans.shape[1]
    nan_percentages = nans.sum(axis=1) / num_genes
    to_keep = nan_percentages < missing_threshold
    print("Keeping  {:8} cells".format(to_keep.sum()))
    print("Filtered {:8} cells".format(np.logical_not(to_keep).sum()))
    return df.loc[to_keep]

def fill_with_median_expression(df):
    cell_medians = df.median(axis=1)
    filled = df.transpose().fillna(cell_medians).transpose()
    return filled

def get_kNNs_for_gene(df, gene_idx, k):
    cur_gene = np.reshape(df.iloc[:,gene_idx].transpose(), (1, -1))
    other_genes = df.drop(df.columns[[gene_idx]], axis=1).transpose()
    other_genes_idx = np.arange(df.shape[1])
    other_genes_idx = np.delete(other_genes_idx, [gene_idx])
    # Get kNN genes
    distances = cdist(cur_gene, other_genes).flatten()
    k_nearest = np.argsort(distances)[:k]
    k_nearest_distances = distances[k_nearest]
    k_nearest_idx = other_genes_idx[k_nearest]
    return k_nearest_idx, k_nearest_distances

def get_kNNs(df, k):
    """Input is (n, g) sample matrix. Return two matrices:
    kNN          (g, k)
    kNN_weights  (g, k)
    For each gene (g genes), contains the k nearest neighbors (either their
    indices or their weights (inverse distances))
    """
    t0 = time.time()
    knn = np.zeros((df.shape[1], k))
    knn_weights = np.zeros((df.shape[1], k))
    for gene in range(df.shape[1]):
        if gene % 1000 == 0:
            print(gene)
        cur_knn, cur_distances = get_kNNs_for_gene(df, gene, k)
        cur_weights = 1 / (cur_distances + np.finfo(float).eps)
        knn[gene, :] = cur_knn
        knn_weights[gene, :] = cur_weights
    print("kNN took: ", time.time()-t0)
    return knn, knn_weights

def get_kNNs2(df, k):
    """Input is (n, g) sample matrix. Return two matrices:
    kNN          (g, k)
    kNN_weights  (g, k)
    For each gene (g genes), contains the k nearest neighbors (either their
    indices or their weights (inverse distances))
    """
    t0 = time.time()
    #knn = np.zeros((df.shape[1], k))
    #knn_weights = np.zeros((df.shape[1], k))
    g = df.shape[1]
    print('calculating dist mat...')
    mat = df.values.astype('float32')
    print(mat.dtype)
    dist_mat = squareform(pdist(mat.T))
    print('dist_mat: ', type(dist_mat))
    print('dist_mat: ', dist_mat.shape)
    print('dist_mat: ', dist_mat.dtype)
    dist_mat = dist_mat.astype('float32')
    print('dist_mat: ', dist_mat.dtype)
    print('done')
    sort_t0 = time.time()
    knn = np.argsort(dist_mat, axis=1)
    #knn_distances = dist_mat[knn]
    print('argsort took: ', time.time()-sort_t0)
    sort_t0 = time.time()
    knn_distances = np.sort(dist_mat, axis=1)
    print('sort took: ', time.time()-sort_t0)
    print('argsorted')
    to_delete_t0 = time.time()
    to_delete = knn == np.arange(g)[:, None]
    print('to_delete took: ', time.time()-to_delete_t0)
    print('got boolean vec')
    where_t0 = time.time()
    _, del_ind = np.where(to_delete)
    print('where took: ', time.time()-where_t0)
    print('done where')
    mask_t0 = time.time()
    mask = np.ones((g,g), dtype=bool)
    mask[range(g), del_ind] = False
    knn = knn[mask].reshape(g, g-1)
    knn_distances = knn_distances[mask].reshape(g, g-1)
    print('masking took: ', time.time()-mask_t0)

    knn = knn[:, :k]
    knn_distances = knn_distances[:, :k]
    knn_weights = 1 / (knn_distances + np.finfo(float).eps)
    
    print("kNN took: ", time.time()-t0)
    return knn, knn_weights

def impute_for_study(df, samples_in_study, k):
    study_df = df.iloc[samples_in_study]
    print("Shape of study subset: ", study_df.shape)
    n, g = study_df.shape
    study_nans = study_df.isnull().values
    study_filled = fill_with_median_expression(study_df)
    assert(study_filled.isnull().values.any() == False)
    knn, knn_weights = get_kNNs2(study_filled, k)
    print(knn.shape)
    print(knn_weights.shape)
    print("done with knn")
    print("imputing")
    impute_t0 = time.time()
    knn_tensor = np.take(study_filled.values, indices=knn, axis=1)
    nan_knn_counts = np.sum(np.isnan(knn_tensor), axis=-1)[study_nans]

    imputed = np.average(knn_tensor, axis=-1, weights=np.broadcast_to(knn_weights, shape=(n, g, k)))
    print("done imputing")
    print("imputing took: ", time.time()-impute_t0)
    #study_df = study_df + study_nans.astype(int) * imputed
    np_study = study_df.values
    #np_study[study_nans] = imputed
    inds = np.where(np.isnan(np_study))
    np_study[inds] = imputed[inds]

    df.iloc[samples_in_study] = np_study
    return nan_knn_counts

def impute_for_study_old(df, samples_in_study, k):
    study_df = df.iloc[samples_in_study]
    print("Shape of study subset: ", study_df.shape)
    study_nans = study_df.isnull()
    gene_has_nans = study_nans.sum(axis=0) > 0
    study_filled = fill_with_median_expression(study_df)
    assert(study_filled.isnull().values.any() == False)
    nan_neighbor_counts = []
    for gene in range(study_df.shape[1]):
        if not gene_has_nans[gene]:
            continue
        print("imputing for gene: ", gene)
        k_nearest_idx, k_nearest_distances = get_kNNs(study_filled, gene, k)
        t0 = time.time()
        for cell in range(study_df.shape[0]):
            if np.isnan(study_df.iloc[cell, gene]):
                nan_neighbor_counts.append(np.sum(study_nans.iloc[cell, k_nearest_idx]))
                imputed = np.average(study_filled.iloc[cell, k_nearest_idx], weights=1/(k_nearest_distances + np.finfo(float).eps))
                study_df.iloc[cell, gene] = imputed
        print("cell for loop took: ", time.time()-t0)
    # Incorporate imputed data into original dataframe
    df.iloc[samples_in_study] = study_df
    return nan_neighbor_counts

def impute_missing_values(df, accessions, k):
    accession_set = np.unique(accessions)
    nan_neighbor_counts = []
    for accn in accession_set:
        samples_in_study = accessions == accn
        study_nan_neighbor_counts = impute_for_study(df, samples_in_study, k)
        nan_neighbor_counts.extend(study_nan_neighbor_counts)
    assert(df.isnull().values.any() == False)
    plt.figure()
    plt.hist(nan_neighbor_counts, bins=np.arange(k+1))
    plt.title('Frequencies of number of NaN nearest neighbors for a missing value')
    plt.xlabel('# k nearest neighbor genes that are NaN in the cell')
    plt.ylabel('frequency')
    plt.savefig('imputation_num_nan_neighbors_hist.png')
    plt.close()


if __name__ == '__main__':
    args = docopt(__doc__)

    h5_store = pd.HDFStore(args['<expression_h5>'])
    print("loaded h5 file")
    rpkm_df = h5_store['rpkm']
    h5_store.close()

    print(rpkm_df.shape)

    rpkm_df = filter_cells(rpkm_df, float(args['--threshold']))
    accessions = get_accessions_from_accessionSeries(rpkm_df.index)
    t0 = time.time()
    impute_missing_values(rpkm_df, accessions, int(args['-k']))
    print("imputation took: ", time.time()-t0)
    
